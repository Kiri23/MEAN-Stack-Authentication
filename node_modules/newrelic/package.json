{
  "_args": [
    [
      {
        "raw": "newrelic@https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
        "scope": null,
        "escapedName": "newrelic",
        "name": "newrelic",
        "rawSpec": "https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
        "spec": "https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
        "type": "remote"
      },
      "C:\\Users\\Yadira\\Desktop\\MEAN-Stack-Authentication-master"
    ]
  ],
  "_from": "https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
  "_id": "newrelic@2.1.0",
  "_inCache": true,
  "_location": "/newrelic",
  "_phantomChildren": {},
  "_requested": {
    "raw": "newrelic@https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
    "scope": null,
    "escapedName": "newrelic",
    "name": "newrelic",
    "rawSpec": "https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
    "spec": "https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
  "_shasum": "89ab35efeb4e207ef068be4b886ab66265c739c8",
  "_shrinkwrap": null,
  "_spec": "newrelic@https://registry.npmjs.org/newrelic/-/newrelic-2.1.0.tgz",
  "_where": "C:\\Users\\Yadira\\Desktop\\MEAN-Stack-Authentication-master",
  "author": {
    "name": "New Relic Node.js agent team",
    "email": "nodejs@newrelic.com"
  },
  "bin": {
    "newrelic-naming-rules": "./bin/test-naming-rules.js"
  },
  "bugs": {
    "url": "https://github.com/newrelic/node-newrelic/issues"
  },
  "contributors": [
    {
      "name": "Saxon D'Aubin",
      "email": "saxon@newrelic.com",
      "url": "http://newrelic.com"
    },
    {
      "name": "Forrest L Norvell",
      "email": "forrest@newrelic.com",
      "url": "http://newrelic.com/"
    },
    {
      "name": "Jacob Groundwater",
      "email": "jacob@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Wraithan",
      "email": "wmcdonald@newrelic.com",
      "url": "Chris McDonald"
    },
    {
      "name": "Michael Hayes",
      "email": "mhayes@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Bryan Clement",
      "email": "bclement@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Jeff Olfert",
      "email": "jolfert@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Wilson Bilkovich",
      "email": "wbilkovich@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Jonathan Merrill",
      "email": "jmerrill@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Martin Kuba",
      "email": "mkuba@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Tim Krajcar",
      "email": "tkrajcar@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Eric Wang",
      "email": "ewang@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Natalie Wolfe",
      "email": "nwolfe@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Seth Shober",
      "email": "sshober@newrelic.com",
      "url": "https://newrelic.com"
    }
  ],
  "dependencies": {
    "@newrelic/native-metrics": "^2.1.0",
    "concat-stream": "^1.5.0",
    "https-proxy-agent": "^0.3.5",
    "json-stringify-safe": "^5.0.0",
    "readable-stream": "^2.1.4",
    "semver": "^5.3.0"
  },
  "description": "New Relic agent",
  "devDependencies": {
    "async": "^2.1.4",
    "bluebird": "^3.4.7",
    "eslint": "^2.9.0",
    "jsdoc": "^3.4.0",
    "minami": "^1.1.1",
    "mocha": "*",
    "tap": "^9.0.3"
  },
  "directories": {
    "lib": "lib"
  },
  "engines": {
    "node": ">=0.10.0",
    "npm": ">=2.0.0"
  },
  "homepage": "http://github.com/newrelic/node-newrelic",
  "keywords": [
    "apm",
    "performance",
    "monitoring",
    "instrumentation",
    "debugging",
    "profiling"
  ],
  "licenses": [
    {
      "type": "proprietary",
      "url": "https://raw.github.com/newrelic/node-newrelic/master/LICENSE"
    }
  ],
  "name": "newrelic",
  "optionalDependencies": {
    "@newrelic/native-metrics": "^2.1.0"
  },
  "readme": "[![npm status badge][1]][2]\n\n# New Relic for Node.js\n\nThis package instruments your application for performance monitoring\nwith [New Relic][4].\n\nMake sure you have a [New Relic account][4] before starting. To see all the\nfeatures, such as slow transaction traces, you will need a [New Relic Pro][5]\nsubscription (or equivalent).\n\nAs with any instrumentation tool, please test before using in production.\n\n## Table of contents\n\n* [Getting started](#getting-started)\n* [Security](#security)\n* [Configuration](#configuring-the-module)\n* [RUM / browser timings](#browser-timings-rum--real-user-monitoring)\n* [Transactions and request naming](#transactions-and-request-naming)\n* [Licensing](#license)\n* [Contributions](#contributions)\n* [Known issues](#known-issues)\n\n## Getting started\n\n1. [Install node](https://nodejs.org/#download). The agent runs on v0.10 and\n   higher. Development work on this module is done with the latest\n   non-development release of Node.\n2. Verify your version of node came with a new enough version of npm using\n   `npm -v`. We require version 1.4.28 or newer, and recommend using\n   the latest release. Read more about [upgrading npm here](#upgrading-npm).\n3. Install this module via `npm install newrelic` for the\n   application you want to monitor.\n4. Copy `newrelic.js` from `node_modules/newrelic` into the root\n   directory of your application.\n5. Edit `newrelic.js` and replace `license_key`'s value with the license key\n   for your account.\n6. Add `require('newrelic');` as the first line of the app's main module.\n\nIf you wish to keep the configuration for the module separate from your\napplication, the module will look for `newrelic.js` in the directory referenced\nby the environment variable `NEW_RELIC_HOME` if it's set.\n\nWhen you start your app, New Relic should start up with it and start reporting\ndata that will appear within [the New Relic UI](https://rpm.newrelic.com/)\nafter a few minutes. Because the agent minimizes the amount of bandwidth it\nconsumes, it only reports data once a minute, so if you require the module in\ntests that take less than a minute to run, it won't have time to report data to\nNew Relic. The module will write its log to a file named `newrelic_agent.log`\nin the application directory. If New Relic doesn't send data or crashes your\napp, the log can help New Relic determine what went wrong, so be sure to send\nit along with any bug reports or support requests.\n\n### Upgrading npm\n\nIf you're running on a version of npm before 1.4.28, or are interested in moving\nup to latest follow these steps:\n\n1. Run `npm -v` to make sure you have npm installed and working.\n2. If you are on linux/smartos/osx/\\*nix run `ls -l $(which npm)` and check to\n   see if the file is owned by \"root\" or \"admin\". If so, prefix the next command\n   with `sudo`.\n3. Run `npm install -g npm@latest` to upgrade npm itself.\n\n**Warning**: An existing installation of npm can break if it is used to upgrade\nitself without root privileges while the npm executable is owned by root.\n\n## Security\n\nWe take security (and the protection of your and your users' privacy) very\nseriously. See [SECURITY.md](SECURITY.md) for details, but the brief version is\nthat if you feel you've found a security issue, contact us at security@newrelic.com.\n\n## Configuring the module\n\nThe module can be tailored to your app's requirements, both from the server and\nvia the `newrelic.js` configuration file you created. For complete details on\nwhat can be configured, refer to [`lib/config.default.js`][6], which documents\nthe available variables and their default values.\n\nIn addition, for those of you running in PaaS environments like Heroku or\nMicrosoft Azure, all of the configuration variables in `newrelic.js` have\ncounterparts that can be set via environment variables. You can mix and match\nvariables in the configuration file and environment variables freely;\nenvironment variables take precedence.\n\nHere's the list of the most important variables and their values:\n\n* `NEW_RELIC_LICENSE_KEY`: Your New Relic license key. This is a required\n  setting with no default value.\n* `NEW_RELIC_APP_NAME`: The name of this application, for reporting to New\n  Relic's servers. This value can be also be a comma-delimited list of names.\n  This is a required setting with no default value. (NOTE: as a convenience to\n  Azure users, the module will use `APP_POOL_ID` as the application name if\n  it's set, so you can use the name you chose for your Azure Web Server without\n  setting it twice.)\n* `NEW_RELIC_NO_CONFIG_FILE`: Inhibit loading of the configuration file\n  altogether. Use with care. This presumes that all important configuration\n  will be available via environment variables, and some log messages assume\n  that a config file exists.\n* `NEW_RELIC_HOME`: path to the directory in which you've placed `newrelic.js`.\n* `NEW_RELIC_USE_SSL`: Use SSL for communication with New Relic's servers.\n  Enabled by default.\n* `NEW_RELIC_LOG`: Complete path to the New Relic agent log, including the\n  filename. The agent will shut down the process if it can't create this file,\n  and it creates the log file with the same umask of the process. Setting this\n  to `stdout` will write all logging to stdout, and `stderr` will write all\n  logging to stderr.\n* `NEW_RELIC_LOG_LEVEL`: Logging priority for the New Relic agent. Can be one\n  of `error`, `warn`, `info`, `debug`, or `trace`. `debug` and `trace` are\n  pretty chatty; unless you're helping New Relic figure out irregularities with\n  the module, you're probably best off using `info` or higher.\n\nFor completeness, here's the rest of the list:\n\n* `NEW_RELIC_ENABLED`: Whether or not the agent should run. Good for\n  temporarily disabling the agent while debugging other issues with your code.\n  It doesn't prevent the module from bootstrapping its instrumentation or\n  setting up all its pieces, it just prevents it from starting up or connecting\n  to New Relic's servers. Defaults to true.\n* `NEW_RELIC_ERROR_COLLECTOR_ENABLED`: Whether or not to trace errors within\n  your application. Values are `true` or `false`. Defaults to true.\n* `NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES`: Comma-delimited list of HTTP\n  status codes to ignore. Maybe you don't care if payment is required? Ignoring\n  a status code means that the transaction is not renamed to match the code,\n  and the request is not treated as an error by the error collector. Defaults\n  to ignoring 404.\n* `NEW_RELIC_IGNORE_SERVER_CONFIGURATION`: Whether to ignore server-side\n  configuration for this application. Defaults to false.\n* `NEW_RELIC_TRACER_ENABLED`: Whether to collect and submit slow transaction\n  traces to New Relic. Values are `true` or `false`. Defaults to true.\n* `NEW_RELIC_TRACER_THRESHOLD`: Threshold of web transaction response time (in\n  seconds) at which a transaction trace will count as slow and be sent to New\n  Relic. Can also be set to `apdex_f`, at which point it will set the trace\n  threshold to 4 times the current ApdexT. Defaults to `apdex_f`.\n* `NEW_RELIC_APDEX`: Set the initial Apdex tolerating / threshold value in\n  seconds.  This is more often than not set from the server. Defaults to 0.100.\n* `NEW_RELIC_CAPTURE_PARAMS`: Whether to capture request parameters on slow\n  transaction or error traces. Defaults to false.\n* `NEW_RELIC_IGNORED_PARAMS`: Some parameters may contain sensitive values you\n  don't want being sent out of your application. This setting is a\n  comma-delimited list of names of parameters to ignore. Defaults to empty.\n* `NEW_RELIC_NAMING_RULES`: A list of comma-delimited JSON object literals:\n  `NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'`\n  See the section on request and transaction naming for details. Defaults to\n  empty.\n* `NEW_RELIC_IGNORING_RULES`: A list of comma-delimited patterns:\n  `NEW_RELIC_IGNORING_RULES='^/socket\\.io/.*/xhr-polling,ignore_me'` Note that\n  currently there is no way to escape commas in patterns. Defaults to empty.\n* `NEW_RELIC_TRACER_TOP_N`: Increase this number to increase the diversity of\n  slow transaction traces sent to New Relic. Defaults to 1. See the description\n  in `lib/config.default.js`, as this feature is exceedingly hard to summarize.\n* `NEW_RELIC_HOST`: Hostname for the New Relic collector. You shouldn't\n  need to change this.\n* `NEW_RELIC_PORT`: Port number on which the New Relic collector will be\n  listening. You shouldn't need to change this either.\n* `NEW_RELIC_PROXY_URL`: A fully-qualified URL to an http/https proxy.\n  The proxy URL may include basic authentication.\n  The use of `NEW_RELIC_PROXY_URL` overrides other proxy settings.\n* `NEW_RELIC_PROXY_HOST`: Proxy hostname\n* `NEW_RELIC_PROXY_PORT`: Proxy port.\n* `NEW_RELIC_PROXY_USER`: Proxy user name (basic auth only).\n* `NEW_RELIC_PROXY_PASS`: Proxy password.\n* `NEW_RELIC_DEBUG_METRICS`: Whether to collect internal supportability metrics\n  for the agent. Don't mess with this unless New Relic asks you to.\n* `NEW_RELIC_DEBUG_TRACER`: Whether to dump traces of the transaction tracer's\n  internal operation. It's unlikely to be informative unless you're a New Relic\n  Node.js engineer and it has a significant performance cost, so use with care.\n* `NEW_RELIC_BROWSER_MONITOR_ENABLE`: Whether to generate browser timing (RUM)\n  headers or not.\n* `NEW_RELIC_LABELS`: Sets the label names and values to associate with the\n  application. The list is a semi-colon delimited list of colon-separated name\n  and value pairs\n\n## Browser timings (RUM / Real User Monitoring)\n\nNew Relic's instrumentation can extend beyond your application into the\nclient's browser.  The `newrelic` module can generate `<script>` headers which,\nwhen inserted into your HTML templates, will capture client-side page load\ntimes.\n\nHeaders must be manually injected, but no extra configuration is necessary to\nenable browser timings.\n\n### Basics\n\n- Insert the result of `newrelic.getBrowserTimingHeader()` into your html page.\n- The browser timing headers should be placed in the beginning of your `<head>` tag.\n  - As an exception to the above, for maximum IE compatability, the results of\n    `getBrowserTimingHeader()` should be placed *after* any\n    `X-UA-COMPATIBLE HTTP-EQUIV` meta tags.\n- Do *not* cache the header, call it once for every request.\n\n### Example\n\nBelow is an example using `express` and `jade`; Express is a popular web\napplication framework, and `jade` is a popular template module.  Although the\nspecifics are different for other frameworks, the general approach described\nbelow should work in most cases.\n\nThe simplest way to insert browser timing headers is to pass the `newrelic`\nmodule into your template, and call `newrelic.getBrowserTimingHeader()` from\nwithin the template.\n\n*app.js:*\n\n```javascript\nvar newrelic = require('newrelic');\nvar app = require('express')();\n\n// In Express, this lets you call newrelic from within a template.\napp.locals.newrelic = newrelic;\n\napp.get('/user/:id', function (req, res) {\n  res.render('user');\n});\napp.listen(process.env.PORT);\n```\n\n*layout.jade:*\n\n```jade\ndoctype html\nhtml\n  head\n    != newrelic.getBrowserTimingHeader()\n    title= title\n    link(rel='stylesheet', href='/stylesheets/style.css')\n  body\n    block content\n```\n\nBy defaults calls to `newrelic.getBrowserTimingHeader()` should return valid\nheaders.  You can disable header generation *without* removing your template\ncode.  In your `newrelic.js` file, add the following to disable header\ngeneration.\n\n```javascript\nexports.config = {\n  // ... other config\n  browser_monitoring : {\n    enable : false\n  }\n};\n```\n\nYou can also set the environment variable `NEW_RELIC_BROWSER_MONITOR_ENABLE=false`.\n\nIt is safe to leave the header generation code in place even when you're not\nusing it.  If browser timings are disabled, or there is an error such that\nworking headers cannot be generated, the `newrelic` module will generate an\ninnocuous HTML comment.  If the `newrelic` module is disabled entirely no\ncontent will be generated.\n\n## Transactions and request naming\n\nIn order to get the most value out of New Relic for Node.js, you may have to do\na little work to help us figure out how your application is structured. New\nRelic works on the assumption that it can group requests to your application\ninto transactions, which are defined by giving one or more request paths a\nname. These names are used to visualize where your app is spending its time (in\ntransaction breakdowns), to identify slow requests, and to group scoped\nmetrics. For example, this can identify slow database queries by showing which\nrequests are spending a long time waiting on the database.\n\nIf you're using Express, Restify or Hapi with their default routers and are\nsatisfied with your application being represented by those frameworks' route\nmatchers, you may not need to do anything. However, if you want more specific\nnames than are provided by your framework, you may want to use one or more of\nthe tools described further on.\n\nThe simplest way to tell that you need to read further in this document is if\nyou feel too many of your requests are being lumped together under the\ncatch-all name `/*`. All requests that aren't otherwise named by the module\nwill end up grouped under `/*`.\n\n### Background\n\nIf you've been working with Node for a while, you're probably accustomed to\nthinking of your application's requests in terms of raw URLs. One of the great\nthings about Node is that it makes it so easy and simple to work with HTTP, and\nthat extends to things like parsing URLs and creating your own strategies for\nnaming and routing requests for services like RESTful APIs. This presents a\nchallenge for New Relic, because we need to keep the number of names we're\ntracking small enough that we can keep the New Relic user experience snappy,\nand also so we don't overwhelm you with so much data that it's difficult for\nyou to see the problem spots in your applications. URLs are not a good fit for\nhow New Relic sees performance.\n\nAnother of Node's great strengths is that it provides a lot of tools that build\non top of the `http` module to simplify writing web services. Unfortunately,\nthat variety greatly complicates things for us, with our limited resources, and\nso we offer a few different tools to help you give us the information we need\nto provide you useful metrics about your application:\n\n* we can read the route names from the Express, Restify, and Hapi routers, if\n  you're using them (and as said above, for many of you, this may be all you\n  need)\n* we offer an API for naming the current request, either with simple names or,\n  if you prefer, grouped into controllers with actions\n* and we support rules stored in your module's configuration that can mark\n  requests to be renamed or ignored based on regular expressions matched\n  against the request's raw URLs (also available as API calls)\n\nRequests are mapped to transaction names using a deterministic process:\n\n1. On an incoming request, the module creates a New Relic transaction that\n   includes the HTTP request method and other metadata. As a fallback (for use\n   in the error tracer), each transaction is named after its raw request URL.\n2. When a framework using a supported router is in use, the agent copies the\n   framework name, route path and request method onto the transaction as its\n   transaction name.\n3. Within handlers, you can make calls to the module's API to explicitly set\n   the name of the route to whatever you want, or mark the route to be ignored\n   (or explicitly not ignored, see the below discussion of rules). As noted\n   below, the last API call wins when there is more than one.\n4. When the transaction is finished (i.e. the response has been completely\n   streamed out to the client), any naming or ignoring rules you have specified\n   in your configuration are applied. **NOTE:** Older versions of the module\n   only applied these rules if nothing else had named the transaction, which\n   made using rules with router-based automatic naming impossible. You must be\n   using the latest version of New Relic to combine naming and ignoring rules\n   with naming set by the router instrumentation.\n5. Finally, New Relic may have its own rules that it applies to the transaction\n   name, either because the request is for something New Relic rolls up by\n   default (i.e. static assets like images or CSS files), or because New Relic\n   is applying rules to remedy metric grouping issues.\n6. If nothing has named the transaction after steps 1-5, the transaction is\n   named `/*`, which puts that request in the undifferentiated, default bucket\n   for requests. This will typically only happen in situations where your\n   application uses either no framework, or a framework with a router that\n   isn't currently supported by New Relic.\n\nLet's go through the naming tools one at a time.\n\n### Router introspection\n\nExpress is the most popular web framework in use within the Node community, and\na number of important services are also using Restify. Both frameworks map\nroutes to handlers, and both use a similar pattern to do so: they match one or\nmore HTTP methods (e.g. `GET` or the ever-popular `OPTIONS` – let's hear it for\nCORS) along with a potentially parameterized path (e.g. `/user/:id`) or a\nregular expression (e.g.  `/^/user/([-0-9a-f]+)$/`). New Relic will capture\nboth those pieces of information in the request name. If you have support for\nslow transaction traces and have enabled `capture_params`, the transaction\ntrace will also have the request's parameters and their values attached to it.\nLikewise, request parameters and their values will be attached to any errors\nrecorded by the agent.\n\nThe only important thing to know about New Relic's support for Express, Restify,\nor Hapi is that if you're dissatisfied with the names it comes up with, you can\nuse the API calls described below to come up with more descriptive names. Also,\nif you use a different web framework or router and would like to see support\nfor it added, please let us know.\n\n### Request naming with the module API\n\nThe API is what's handed back from `require('newrelic')`, so\n\n```javascript\nvar newrelic = require('newrelic');\n```\n\nis all you need. Please note that you still need to ensure that loading the New\nRelic module is the first thing your application does, as it needs to bootstrap\nitself before the rest of your application loads, but you can safely require\nthe module from multiple modules in your application – it will only initialize\nitself once.\n\n#### newrelic.setTransactionName(name)\n\nName the current request. You can call this function anywhere within the\ncontext of an HTTP request handler, at any time after handling of the request\nhas started, but before the request has finished. A good rule of thumb is that\nif the request and response objects are in scope, you can set the name.\n\nExplicitly calling `newrelic.setTransactionName()` will override any names set\nby Express, Restify or Hapi routes. Calls to `newrelic.setTransactionName()` and\n`newrelic.setControllerName()` will overwrite each other. The last call made\nbefore the request ends wins.\n\n**VERY IMPORTANT NOTE:** Do not include highly variable information like GUIDs,\nnumerical IDs, or timestamps in the request names you create. If your request\nis slow enough to generate a transaction trace, that trace will contain the\noriginal URL. If you enable parameter capture, the parameters will also be\nattached to the trace. The request names are used to group requests for New\nRelic's many charts and tables, and those visualizations' value drops as the\nnumber of different request names increases. If you have 50 or so different\ntransaction names, you're probably pushing it. If you have more than a couple\nhundred, you need to rethink your naming strategy.\n\n#### newrelic.setControllerName(name, [action])\n\nName the current request using a controller-style pattern, optionally including\nthe current controller action. If the action is omitted, New Relic will include\nthe HTTP method (e.g. `GET`, `POST`) as the action. The rules for when you can\ncall `newrelic.setControllerName()` are the same as they are for\n`newrelic.setTransactionName()`.\n\nExplicitly calling `newrelic.setControllerName()` will override any names set by\nExpress, Restify, or Hapi routes. Calls to `newrelic.setTransactionName()` and\n`newrelic.setControllerName()` will overwrite each other. The last one to run\nbefore the request ends wins.\n\nSee the above note on `newrelic.setTransactionName()`, which also applies to\nthis function.\n\n### Rules for naming and ignoring requests\n\nIf you don't feel like putting calls to the New Relic module directly into your\napplication code, you can use pattern-based rules to name requests. There are\ntwo sets of rules: one for renaming requests, and one to mark requests to be\nignored by New Relic.\n\nIf you're using socket.io, you will have a use case for ignoring rules right\nout of the box. You'll probably want to add a rule like the following:\n\n```javascript\n// newrelic.js\nexports.config = {\n  // other configuration\n  rules : {\n    ignore : [\n      '^/socket.io/.*/xhr-polling'\n    ]\n  }\n};\n```\n\nThis will keep socket.io long-polling from dominating your response-time\nmetrics and blowing out the apdex metrics for your application.\n\n#### rules.name\n\nA list of rules used to set the name of the transaction to `name` when the URL\nmatches `pattern`.\n\nCan also be set via the environment variable `NEW_RELIC_NAMING_RULES`, with\nmultiple rules passed in as a list of comma-delimited JSON object literals:\n`NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'`\n\nEach rule is defined using the following format:\n\n```\n{\n  // required\n  pattern : \"pattern\",\n  name : \"name\",\n\n  // optional\n  precedence: 1,\n  terminate_chain: true,\n  replace_all: false\n}\n```\n\nAdditional attributes are ignored.\n\nNote: these rules take precedence over automatic naming from router instrumentations and\nare applied to the URL path, not the name returned by the router instrumentation.\n\n##### pattern (required)\n\nThe pattern used to match the URL.  It can be set as either a string or a JavaScript\nregular expression literal.  For example, `\"^/abc/123$\"` is equivalent to `/^\\/abc\\/123$/`.\n\nThe pattern can be written to match the complete URL, or just a part of it.\n\n##### name (required)\n\nThe value that is used to replace the URL (or part of it) that matches the pattern.\nIt is also possible to use regular expression group references.  See examples below.\n\n##### rules.precedence (optional)\n\nBy default the rules are evaluated in reverse order (from last to first).  If you find\nthis behavior counterintuitive, the execution order can be reversed by setting the feature\nflag `reverse_naming_rules` to false.  Furthermore, if you prefer to have complete\ncontrol over the order, each rule can be given a `precedence` attribute.  The precedence\nis an integer number, and rules are evaluated in ascending order.  If precedence is not\nexplicitly defined, it will be set to 500 by default.\n\n##### rules.terminate_chain (optional)\n\nWhen set to true, no further rules will be evaluated if this rule is a match.  The default\nis true.\n\nSetting this to false is useful when multiple rules should be used together.  For example,\none rule could be replacing a common pattern in many different URLs, while subsequent\nrule(s) would be more specific.\n\n##### rules.replace_all (optional)\n\nWhen set to true, all matches of the pattern will be replaced.  Otherwise, only the first\nmatch will be replaced.  The default is false.  Using the `g` flag with regular expression\nliteral will have the same effect.  For example:\n\n```\n  pattern: '[0-9]+',\n  replace_all: true\n```\n\nwill have the same effect as\n\n```\n  pattern: /[0-9]+/g\n```\n\n##### Testing\n\nThe agent comes with a command-line tool for testing naming rules.  For more information\nrun the following command in terminal window in a directory where your app is installed.\n\n`node node_modules/.bin/newrelic-naming-rules`\n\n##### Examples\n\nMatch full URL:\n\n```\n  pattern: \"^/items/[0-9]+$\",\n  name: \"/items/:id\"\n```\n\nReplace the first match in any URL:\n\n```\n  pattern: \"[0-9]+\",\n  name: \":id\"\n```\n\nwill result in:\n\n`/orders/123` => `/orders/:id`\n\n`/items/123` => `/items/:id`\n\n`/orders/123/items/123` => `/orders/:id/items/123`\n\nReplace all matches in any URL:\n\n```\n  pattern: \"[0-9]+\",\n  name: \":id\",\n  replace_all: true\n```\n\nwill result in:\n\n`/orders/123/items/123` => `/orders/:id/items/:id`\n\nUsing regular expression match group references:\n\n```\n  pattern: '^/(items|orders)/[0-9]+$',\n  name: '/\\\\1/:id'\n```\n\nwill result in:\n\n`/orders/123` => `/orders/:id`\n\n`/items/123` => `/items/:id`\n\n\n#### rules.ignore\n\nA list of patterns for matching incoming request URLs to be ignored. When using\nignoring rules with instrumented routers, the matches are still made against\nthe URL paths, not the name returned by the router instrumentation. Patterns may be\nstrings or regular expressions.\n\nCan also be set via the environment variable `NEW_RELIC_IGNORING_RULES`, with\nmultiple rules passed in as a list of comma-delimited patterns:\n`NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me'` Note that\ncurrently there is no way to escape commas in patterns.\n\n### API for adding naming and ignoring rules\n\n#### newrelic.addNamingRule(pattern, name)\n\nProgrammatic version of `rules.name` above. Naming rules can not be removed\nuntil the Node process is restarted. They can also be added via the module's\nconfiguration. Both parameters are mandatory.\n\n#### newrelic.addIgnoringRule(pattern)\n\nProgrammatic version of `rules.ignore` above. Ignoring rules can not be removed\nuntil the Node process is restarted. They can also be added via the module's\nconfiguration. The pattern is mandatory.\n\n### Other API calls\n\n#### newrelic.addCustomParameter(name, value)\n\nSet a custom parameter value to be attached to a transaction trace and/or error\nin the New Relic UI. This must be called within the context of a transaction,\nso it has a place to set the custom parameters.\n\n#### newrelic.addCustomParameters(params)\n\nSet multiple custom parameter values to be attached to a transaction trace and/or\nerror in the New Relic UI. This must be called within the context of a transaction,\nso it has a place to set the custom parameters.\n\nExample of setting multiple custom parameters at once:\n\n```javascript\nnewrelic.addCustomParameters({test: 'value', test2: 'value2'});\n```\n\n#### newrelic.setIgnoreTransaction(ignored)\n\nTell the module explicitly whether or not a given request should be ignored.\nAllows you to explicitly filter out long-polling routes or requests you know\nare going to be time-consuming in an uninteresting way, and also allows you\nto gather metrics for requests that would otherwise be ignored. Note that\nto prevent a transaction from being ignored with this function, you **must**\npass `false` as the parameter – in this case `null` or `undefined` will be\nignored.\n\n#### newrelic.noticeError(error, customParameters)\n\nIf your app is doing its own error handling with domains or try/catch clauses,\nbut you want all of the information about how many errors are coming out of the\napp to be centrally managed, use this call. Unlike most of the calls here, this\nfunction can be used outside of route handlers, but will have additional\ncontext if called from within transaction scope. If custom parameters are\npassed in on an object literal, they will be passed back to New Relic for\ndisplay.\n\n#### newrelic.shutdown([options], callback)\n\nUse this method to gracefully shut down the agent.  When called with\n`options.collectPendingData` set to true, the agent will send any pending data\nto the New Relic servers before shutting down.  This is useful when you want to\nshut down the Node process and make sure that all transactions and/or errors are\ncaptured by New Relic.\n\nExample of collecting pending data before shutting down the process:\n\n```javascript\nnewrelic.shutdown({ collectPendingData: true }, function(error) {\n  process.exit()\n})\n```\n\n### Custom Instrumentation\n\nCustom transaction should be used for instrumenting `socket.io` or other\nvarieties of socket servers, and background jobs. These are things that the\nagent can't automatically instrument because without your knowledge of your\napplication, the agent can't tell when they should begin and end.\n\nRead more at:\nhttps://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-custom-instrumentation\n\n#### newrelic.createWebTransaction(url, handle)\n\n`url` is the name of the web transaction. It should be pretty static, not\nincluding anything like user ids or any other data that is very specific to the\nrequest. `handle` is the function you'd like to wrap in the web transaction.\nBoth custom and auto instrumentation will be captured as part of the\ntransaction.\n\nIf called within an active web transaction, it will act as a nested tracer. If\ncalled within an active background transaction, it will create a new,\nindependent transaction and any calls within the `handle` will be bound to the\nnew web transaction.\n\nCustom transactions **must** be ended manually by calling `endTransaction()`.\nTiming for custom transaction starts from when the returned wrapped function is\ncalled until `endTransaction()` is called.\n\n#### newrelic.createBackgroundTransaction(name, [group], handle)\n\n`name` is the name of the job. It should be pretty static, and not include job\nids or anything very specific to that run of the job. `group` is optional, and\nallows you to group types of jobs together. This should follow similar rules as\nthe `name`. `handle` is a function that encompases your background job. Both\ncustom and auto instrumentation will be captured as part of the transaction.\n\nIf called within an active background transaction, it will act as a nested\ntracer. If called within an active web transaction, it will create a new\ntransaction and any calls within the `handle` will be bound to the new,\nindependent background transaction.\n\nCustom transactions **must** be ended manually by calling `endTransaction()`.\nTiming for custom transaction starts from when the returned wrapped function is\ncalled until `endTransaction()` is called.\n\n#### newrelic.endTransaction()\n\nThis takes no arguments and must be called to end any custom transaction. It\nwill detect what kind of transaction was active and end it.\n\n#### newrelic.createTracer(name, handle)\n\n`name` is the name of the tracer. It will show up as a segment in your\ntransaction traces and create its own metric. `handle` is the function to be\nbound to the tracer.\n\nTiming is from when `createTracer` is called until the `handle` done executing.\nThis should be called inside of a transaction to get data. If it is called\noutside of a transaction it will just pass through.\n\n#### newrelic.recordMetric(name, value)\n\n`name` is the metric name to record, it must be a string that begins with\n`Custom/` typically followed by segments for `category` and `label`.\n(eg.`Custom/my_category/my_label`).\n`value` is either a numerical value to associate with the metric sample,\nor an object representing multiple samples for the metric. If `value` is\nan object, it must include keys for `count`, `total`, `min`, `max`, and\n`sumOfSquares`.\n\n#### newrelic.incrementMetric(name[, amount])\n\n`name` is the metric name to record, it must be a string that beings with\n`Custom/` typically followed by segments for `category` and `label`.\n(eg.`Custom/my_category/my_label`).\n`amount` is optional, but must be an integer if provided.  `amount` is\nthe number of times to increment the metrics `count`, it defaults to 1.\n\n### The fine print\n\nThis is the Node-specific version of New Relic's transaction naming API\ndocumentation. The naming API exists to help us deal with the very real problem\nthat trying to handle too many metrics will make New Relic slow for everybody,\nnot just the account with too many metrics. If, in conversation with New Relic\nSupport, you see discussion of \"metric explosion\", this is what they're talking\nabout.\n\nWhile we have a variety of strategies for dealing with these issues, the most\nsevere is simply to blacklist offending applications. The main reason for you\nto be careful in using our request-naming tools is to prevent that from\nhappening to your applications. We will do everything in our power to ensure\nthat you have a good experience with New Relic even if your application is\ncausing us trouble, but sometimes this will require manual intervention on the\npart of our team, and this can take a little while.\n\n## Contributions\n\nWe owe a debt to all of the beta testers and users who have provided us with\nfeedback, and in some cases significant pieces of code. (If you wish to\ncontribute, please see CONTRIBUTING.md in this directory.) In particular, we're\nindebted to these people:\n\n* Hernan Silberman, for his work on the memcached instrumentation.\n* Jeff Howell &lt;jhowell@kabam.com&gt;, for coming up with a much simpler way\n  to instrument node-mongodb-native, as well as pointing out a problem with the\n  Connect instrumentation.\n\n## Recent changes\n\nInformation about changes to the module are in [NEWS.md](NEWS.md).\n\n### Known issues:\n\n* New Relic for Node is only supported on Node.js 0.10 and newer. Some features\n  may behave differently between the supported versions of Node. The agent is\n  optimized for newer versions of Node.\n* There are irregularities around transaction trace capture and display.  If\n  you notice missing or incorrect information from transaction traces, let us\n  know.\n* There are <del>over 20,000</del> <del>30,000</del> <del>40,000</del> <ins>*A\n  LOT* of</ins> modules on npm. We can only instrument a tiny number of them.\n  Even for the modules we support, there are a very large number of ways to use\n  them. If you see data you don't expect on New Relic and have the time to\n  produce a reduced version of the code that is producing the strange data, it\n  will be used to improve the module and you will have the Node team's\n  gratitude.\n* The CPU and memory overhead incurred by New Relic for Node is relatively\n  minor (~1-10%, depending on how much of the instrumentation your apps end up\n  using). GC activity is significantly increased while the agent is active, due\n  to the large number of ephemeral objects created by metrics gathering.\n* When using Node's included clustering support, each worker process will open\n  its own connection to New Relic's servers, and will incur its own overhead\n  costs.\n\n### New Relic features available for other platforms not yet in Node.js\n\n* custom metrics\n* explain plans\n* garbage collector instrumentation\n* thread profiling\n* X-ray transactions (depends on thread profiling)\n* capacity planning\n\n## LICENSE\n\nNew Relic for Node is free-to-use, proprietary software. Please see the full\nlicense (found in [LICENSE](LICENSE) in this distribution) for details on its license and\nthe licenses of its dependencies.\n\n\n[1]: https://nodei.co/npm/newrelic.png\n[2]: https://nodei.co/npm/newrelic\n[3]: https://www.npmjs.com/package/newrelic\n[4]: https://newrelic.com\n[5]: https://newrelic.com/application-monitoring/features\n[6]: https://github.com/newrelic/node-newrelic/blob/master/lib/config.default.js\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/newrelic/node-newrelic.git"
  },
  "scripts": {
    "test": "make test"
  },
  "version": "2.1.0"
}
